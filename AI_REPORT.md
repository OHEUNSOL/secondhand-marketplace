# AI 활용 보고서

## 1) 사용한 AI 도구 목록
- Codex (GPT-5 기반)
- Gemini

## 2) AI를 활용한 핵심 의사결정 3가지

### 의사결정 1: 백엔드 레이어 구조
- 질문: FastAPI 프로젝트를 요구사항 규모에 맞게 어떻게 분리할지?
- AI 제안: `router -> service -> repository -> model/schema` 분리
- 적용 방식: 엔드포인트/비즈니스/DB 접근을 분리해 기능 추가 시 영향 범위를 줄이도록 채택
- 최종 효과: 인증/상품/장바구니/구매/관리자 기능을 독립적으로 확장 가능

### 의사결정 2: 동시 구매 방지 전략
- 질문: 동일 상품 동시 구매를 최소 변경으로 막는 방법은?
- AI 제안: 구매 시점에 조건부 원자적 업데이트(판매중일 때만 판매완료로 전환)
- 적용 방식: `mark_sold_if_available` 도입 후 성공한 트랜잭션만 구매내역 생성
- 최종 효과: 경쟁 상황에서 중복 구매 레코드 생성 방지

### 의사결정 3: 프론트 사용자 경험 개선
- 질문: 장바구니 조작 체감 속도를 높이면서 실패 복구를 보장하는 방법은?
- AI 제안: 낙관적 업데이트 + 실패 시 롤백
- 적용 방식: 수량 변경/삭제/선택 구매를 UI 선반영 후 API 실패 시 이전 상태 복원
- 최종 효과: 반응성 개선 + 데이터 정합성 유지

## 3) AI 생성 코드 중 직접 수정/개선한 부분 (Before/After)

### 개선 사례 1: 공개 상품 목록 인증 의존성
- Before(AI 생성): 공개 상품 목록 조회에서 인증 사용자 의존성을 강제
- After(수정): `get_current_user_optional`을 추가해 비로그인 사용자도 목록 조회 가능
- 수정 이유: 요구사항상 목록은 공개 조회가 가능해야 하며, 관리자만 블라인드 포함 조회가 필요

### 개선 사례 2: 구매 동시성 처리
- Before(AI 초기안): 조회 후 상태 변경 방식(`SELECT -> 상태 확인 -> UPDATE`) 중심
- After(수정): 조건부 원자적 업데이트(`ON_SALE`일 때만 `SOLD`) 기반으로 변경
- 수정 이유: 경쟁 요청에서 이중 구매 가능성을 낮추기 위해 DB 조건 기반 처리로 전환

## 4) AI 없이는 어려웠던 부분 vs AI 도움 없이 직접 판단한 부분

### AI 없이는 어려웠던 부분
- FastAPI/SQLAlchemy 구조를 짧은 시간 내 일관되게 확장하는 초기 설계
- 반복적인 API 연결 코드와 상태 처리(로딩/에러/성공)의 빠른 초안 작성
- 테스트 시나리오를 요구사항 항목별로 빠르게 커버하는 테스트 스캐폴딩

### AI 도움 없이 직접 판단한 부분
- 기능 우선순위와 구현 범위 확정(필수 요구사항 우선)
- 로컬 실행 기준 운영 전략(Docker Compose + 단순 환경변수)
- 도메인 규칙 정의(본인 상품 구매 금지, 판매완료 상품 수정/삭제 제한, 블라인드 정책)
- 제출물 기준 문서 구성 및 항목 완성
